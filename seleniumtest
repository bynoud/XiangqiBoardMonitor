
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.common.by import By
from selenium.common.exceptions import TimeoutException
import threading, time

from selenium import webdriver
options = webdriver.ChromeOptions()
options.add_experimental_option('excludeSwitches', ['enable-logging'])
driver = webdriver.Chrome(options=options)
driver.get('https://google.com')

ID_SIDE = 'xhSideContent'
ID_CONTROL_MOVETIME = 'xhCtrlMovetime'
ID_CONTROL_MULTIPV = 'xhCtrlMultipv'
ID_CONTROL_LOGTEXT = 'xhCtrlLogtext'

def wait_for_reload():
    def webwait():
        try:
            WebDriverWait(driver, 3).until(EC.none_of(EC.presence_of_element_located((By.ID, ID_SIDE))))
            print('reloaded')
        except TimeoutException:
            print('rerun wait')
            webwait()
    threading.Thread(target=webwait, daemon=True).start()

sideDiv = driver.find_element(By.ID, ID_SIDE)

def load_js(filename):
    with open(filename) as f:
        data = f.read()
    driver.execute_script(data)



movetimeEle = driver.find_element(By.ID, ID_CONTROL_MOVETIME)
multipvEle = driver.find_element(By.ID, ID_CONTROL_MULTIPV) #.get_attribute('value')
logareaEle = driver.find_element(By.ID, ID_CONTROL_LOGTEXT)

stopping = False
guiOptions = dict(movetime=2, multipv=1)
def start_gui_polling():
    def poll():
        while not stopping:
            val = movetimeEle.get_attribute('value')
            if val != guiOptions['movetime']:
                guiOptions['movetime'] = val
                print(f'movetime = {val}')
            val = multipvEle.get_attribute('value')
            if val != guiOptions['multipv']:
                guiOptions['multipv'] = val
                print(f'multipv = {val}')
            time.sleep(0.5)
    threading.Thread(target=poll).start()
